// SWAMI KARUPPASWAMI THUNNAI

#include "upx.h"

struct IMAGE_DOS_HEADER {      // DOS .EXE header
	unsigned short   e_magic;                     // Magic number
	unsigned short   e_cblp;                      // Bytes on last page of file
	unsigned short   e_cp;                        // Pages in file
	unsigned short   e_crlc;                      // Relocations
	unsigned short   e_cparhdr;                   // Size of header in paragraphs
	unsigned short   e_minalloc;                  // Minimum extra paragraphs needed
	unsigned short   e_maxalloc;                  // Maximum extra paragraphs needed
	unsigned short   e_ss;                        // Initial (relative) SS value
	unsigned short   e_sp;                        // Initial SP value
	unsigned short   e_csum;                      // Checksum
	unsigned short   e_ip;                        // Initial IP value
	unsigned short   e_cs;                        // Initial (relative) CS value
	unsigned short   e_lfarlc;                    // File address of relocation table
	unsigned short   e_ovno;                      // Overlay number
	unsigned short   e_res[4];                    // Reserved words
	unsigned short   e_oemid;                     // OEM identifier (for e_oeminfo)
	unsigned short   e_oeminfo;                   // OEM information; e_oemid specific
	unsigned short   e_res2[10];                  // Reserved words
	unsigned long    e_lfanew;                    // File address of new exe header
};

//
// File header format.
//
struct IMAGE_FILE_HEADER {
	unsigned short    Machine;
	unsigned short    NumberOfSections;
	unsigned long     TimeDateStamp;
	unsigned long     PointerToSymbolTable;
	unsigned long     NumberOfSymbols;
	unsigned short    SizeOfOptionalHeader;
	unsigned short    Characteristics;
};

//
// Directory format.
//
struct IMAGE_DATA_DIRECTORY {
	unsigned long   VirtualAddress;
	unsigned long   Size;
};

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16


//
// Optional header format.
//
struct IMAGE_OPTIONAL_HEADER32 {
	//
	// Standard fields.
	//

	unsigned short    Magic;
	unsigned char     MajorLinkerVersion;
	unsigned char     MinorLinkerVersion;
	unsigned long     SizeOfCode;
	unsigned long     SizeOfInitializedData;
	unsigned long     SizeOfUninitializedData;
	unsigned long     AddressOfEntryPoint;
	unsigned long     BaseOfCode;
	unsigned long     BaseOfData;

	//
	// NT additional fields.
	//

	unsigned long     ImageBase;
	unsigned long     SectionAlignment;
	unsigned long     FileAlignment;
	unsigned short    MajorOperatingSystemVersion;
	unsigned short    MinorOperatingSystemVersion;
	unsigned short    MajorImageVersion;
	unsigned short    MinorImageVersion;
	unsigned short    MajorSubsystemVersion;
	unsigned short    MinorSubsystemVersion;
	unsigned long     Win32VersionValue;
	unsigned long     SizeOfImage;
	unsigned long     SizeOfHeaders;
	unsigned long     CheckSum;
	unsigned short    Subsystem;
	unsigned short    DllCharacteristics;
	unsigned long     SizeOfStackReserve;
	unsigned long     SizeOfStackCommit;
	unsigned long     SizeOfHeapReserve;
	unsigned long     SizeOfHeapCommit;
	unsigned long     LoaderFlags;
	unsigned long     NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
};

struct IMAGE_OPTIONAL_HEADER64 {
	unsigned short        Magic;
	unsigned char         MajorLinkerVersion;
	unsigned char         MinorLinkerVersion;
	unsigned long         SizeOfCode;
	unsigned long         SizeOfInitializedData;
	unsigned long         SizeOfUninitializedData;
	unsigned long         AddressOfEntryPoint;
	unsigned long         BaseOfCode;
	unsigned long long    ImageBase;
	unsigned long         SectionAlignment;
	unsigned long         FileAlignment;
	unsigned short        MajorOperatingSystemVersion;
	unsigned short        MinorOperatingSystemVersion;
	unsigned short        MajorImageVersion;
	unsigned short        MinorImageVersion;
	unsigned short        MajorSubsystemVersion;
	unsigned short        MinorSubsystemVersion;
	unsigned long         Win32VersionValue;
	unsigned long         SizeOfImage;
	unsigned long         SizeOfHeaders;
	unsigned long         CheckSum;
	unsigned short        Subsystem;
	unsigned short        DllCharacteristics;
	unsigned long long    SizeOfStackReserve;
	unsigned long long    SizeOfStackCommit;
	unsigned long long    SizeOfHeapReserve;
	unsigned long long    SizeOfHeapCommit;
	unsigned long         LoaderFlags;
	unsigned long         NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
};

struct IMAGE_NT_HEADERS64 {
	unsigned long Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

struct IMAGE_NT_HEADERS32 {
	unsigned long Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

//
// Section header format.
//
#define IMAGE_SIZEOF_SHORT_NAME              8

struct IMAGE_SECTION_HEADER {
	unsigned char    Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		unsigned long   PhysicalAddress;
		unsigned long   VirtualSize;
	} Misc;
	unsigned long   VirtualAddress;
	unsigned long   SizeOfRawData;
	unsigned long   PointerToRawData;
	unsigned long   PointerToRelocations;
	unsigned long   PointerToLinenumbers;
	unsigned short  NumberOfRelocations;
	unsigned short  NumberOfLinenumbers;
	unsigned long   Characteristics;
};

bool is_upx(std::string fileName)
{
	std::ifstream filestream(fileName.c_str(), std::ios::binary);

	if (filestream.is_open())
	{
		// Parse PE-Headers
		IMAGE_DOS_HEADER DOS_RAW;
		IMAGE_NT_HEADERS32 INH_RAW; // IMAGE_NT_HEADERS64 INH_RAW;
		IMAGE_SECTION_HEADER ISH_RAW;

		filestream.read((char*)&DOS_RAW, sizeof(IMAGE_DOS_HEADER));
		filestream.seekg(DOS_RAW.e_lfanew, std::ios_base::beg);
		filestream.read((char*)&INH_RAW, sizeof(IMAGE_NT_HEADERS32));
		filestream.read((char*)&ISH_RAW, sizeof(IMAGE_SECTION_HEADER));

		if (DOS_RAW.e_magic == 0x5A4D)
		{
			int count = 0;
			for (unsigned short i = 0; i < INH_RAW.FileHeader.NumberOfSections; i++)
			{
				if (!strncmp((const char*)ISH_RAW.Name, "UPX", 3))
					count++;
				filestream.read((char*)&ISH_RAW, sizeof(IMAGE_SECTION_HEADER));
			}
			if (count > 0) {
				filestream.close();
				return true;
			}
		}
		filestream.close();
	}
	return false;
}
