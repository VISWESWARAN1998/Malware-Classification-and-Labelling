// SWAMI KARUPPASWAMI THUNNAI

#include <iostream>
#include <fstream>
#include <vector>
#include "create_dictionary.h"
#include "md5.h"
#include "upx.h"



create_dictionary::create_dictionary()
{
	// Load all scanned hashes in the constructor
	std::ifstream file;
	file.open("scanned_hash.txt");
	if (file.is_open())
	{
		while (!file.eof())
		{
			std::string hash;
			std::getline(file, hash);
			scanned_hash.insert(hash);
		}
		file.close();
	}
}


create_dictionary::~create_dictionary()
{
}

std::string create_dictionary::calculate_md5(std::string file_location)
{
	char *cstr = new char[file_location.length() + 1];
	strcpy(cstr, file_location.c_str());
	std::string hash = CALL_MD5_Function(cstr);
	delete[] cstr;
	return hash;
}

void create_dictionary::mark_hash_as_scanned(std::string hash)
{
	scanned_hash.insert(hash);
	std::ofstream file;
	file.open("scanned_hash.txt", std::ios::app);
	if (file.is_open())
	{
		file << hash << "\n";
		file.close();
	}
}

bool create_dictionary::is_file_scanned(std::string hash)
{
	if (scanned_hash.find(hash) != scanned_hash.end())
	{
		return true;
	}
	return false;
}

void create_dictionary::create(std::string file_location)
{
	std::string md5 = calculate_md5(file_location);
	if (is_file_scanned(md5)) 
	{
		std::cout << file_location << " is already scanned.\n";
		return;
	}
	mark_hash_as_scanned(md5);
	if (is_upx(file_location))
	{
		std::ofstream file;
		file.open("packed.txt", std::ios::app);
		if (file.is_open())
		{
			file << md5 << " is packed.\n";
			file.close();
		}
		return;
	}
	std::vector<std::string> import = get_import_function(file_location.c_str());
	std::ofstream freq;
	freq.open("frequency.txt", std::ios::app);
	if (freq.is_open())
	{
		for (std::string s : import)
		{
			if (!is_unicode_present(s))
			{
				freq << s << "\n";
			}
		}
		freq.close();
	}
	std::ofstream individual;
	individual.open(md5 + ".txt");
	if (individual.is_open())
	{
		for (std::string s : import)
		{
			individual << s << "\n";
		}
		individual.close();
	}
}

std::vector<std::string> create_dictionary::get_import_function(LPCTSTR exeFileName)
{
	HANDLE hFile, hFileMap;
	DWORD dwImportDirectoryVA, dwSectionCount, dwSection = 0, dwRawOffset;
	LPVOID lpFile;
	PIMAGE_DOS_HEADER pDosHeader;
	PIMAGE_NT_HEADERS pNtHeaders;
	PIMAGE_SECTION_HEADER pSectionHeader;
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor;
	PIMAGE_THUNK_DATA pThunkData;

	std::vector<std::string> result;
	try
	{
		hFile = CreateFile(exeFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			hFileMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
			lpFile = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
			pDosHeader = (PIMAGE_DOS_HEADER)lpFile;
			pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFile + pDosHeader->e_lfanew);
			dwSectionCount = pNtHeaders->FileHeader.NumberOfSections;
			dwImportDirectoryVA = pNtHeaders->OptionalHeader.DataDirectory[1].VirtualAddress;

			pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(IMAGE_NT_HEADERS));
			for (; dwSection < dwSectionCount && pSectionHeader->VirtualAddress <= dwImportDirectoryVA; pSectionHeader++, dwSection++);
			pSectionHeader--;

			dwRawOffset = (DWORD)lpFile + pSectionHeader->PointerToRawData;
			pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(dwRawOffset + (dwImportDirectoryVA - pSectionHeader->VirtualAddress));
			for (; pImportDescriptor->Name != 0; pImportDescriptor++)
			{
				//printf("\nDLL Name : %s\n\n", dwRawOffset + (pImportDescriptor->Name - pSectionHeader->VirtualAddress));
				pThunkData = (PIMAGE_THUNK_DATA)(dwRawOffset + (pImportDescriptor->FirstThunk - pSectionHeader->VirtualAddress));
				for (; pThunkData->u1.AddressOfData != 0; pThunkData++)
				{
					char buffer[10000];
					char* c = (char*)(dwRawOffset + (pThunkData->u1.AddressOfData - pSectionHeader->VirtualAddress + 2));
					if ((DWORD)c < 0x80000000)
					{
						//sprintf_s(buffer, "\tFunction : %s\n", (dwRawOffset + (pThunkData->u1.AddressOfData - pSectionHeader->VirtualAddress + 2)));
						result.push_back(std::string(c));
					}
					else
						break;
				}

			}
			UnmapViewOfFile(lpFile);
			CloseHandle(hFileMap);
			CloseHandle(hFile);
		}
	}
	catch (...)
	{

	}
	return result;
}

bool create_dictionary::is_unicode_present(std::string function_name)
{
	for (char c : function_name)
	{
		if (c > 127) return true;
	}
	return false;
}
